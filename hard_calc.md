# ハードウェアによる演算

ハードウェアでは信号伝搬の最適化のために, 単純な四則演算であっても適切な設計を求められる.
ハードウェアによる数値演算のほとんどは『[ディジタル数値演算回路の実用設計](https://books.google.co.jp/books/about/%E3%83%87%E3%82%A3%E3%82%B8%E3%82%BF%E3%83%AB%E6%95%B0%E5%80%A4%E6%BC%94%E7%AE%97%E5%9B%9E%E8%B7%AF%E3%81%AE%E5%AE%9F.html?id=q5tpGQAACAAJ&source=kp_book_description&redir_esc=y)』が詳しいので, これでほとんど済む.
『ディジタル~』ではASICのためにビット演算に関しても詳しく書かれているが, FPGAのコンパイラによって設計する場合はそこまでは求められない.
そのため本稿でもビット演算については立ち入らない.
というか『ディジタル~』を読めばすべてが事足りる.

以下の四則演算ではまず整数演算について考える.
そのあと量子化や固定小数点について考える.
浮動小数点は諦めよう.

## 加算

まず自然数同士における加算を考える.
$ a + b ,~ a \in \Z, b \in \Z $
二進法における加算はたとえ二項加算であっても, 複数の加算器(Half adder)を用いる.
並列化するために加算器を桁数分並べることになるが, キャリが伝搬するので…
といろいろ考える必要があるような気がするが今のコンパイラは賢いので, 加算演算`+`を使って推論させるのが最も効率がよい.
ここで注意すべきは最上位ビットの桁あふれである.
このとき考えられる対策は
- 桁あふれを通知する
- 最大値で張り付く

である.
最上位ビット(`a(a'left)`)を監視して対策するしかない.

3項以上の多項演算も$\mathrm{ceil}(n/2)$（n/2の切り上げ）の並列な二項演算に分解できる.
例えば$a+b+c+d=x$の4項(n=4)の演算は$a+b=a' , c+d=c' , a'+c'=x$となり, 2並列な演算である.

## 減算

### 演算自体が固定の場合
演算が必ず$a-b$のとき, $a, b$は必ず自然数である.
ここで$a>b$であれば$a-b=x$も必ず自然数であるが, 
$a<b$を含むときは$x$は整数のため, 2の補数などの負数の表現を定義する必要がある.
この符号拡張のため, ビット幅は増加する.
例えば2の補数に拡張する場合は, 最上位に`0b10`を追加してやることになる.
ex. $1-7$

```
   (10000)
      001      1
-)    111   -) 7
---------   ----
```
```
   (10)        2
  1111        -1
-) 111     -) -7
------     -----
  1010        -6
```

そのため一時的に2ビット増加することになる（減算による桁落ちで結果は1ビット分の増加になる）.
負数が必ず発生するようであれば, 浮動小数点のように符号ビットをあらかじめ用意してやっても良い.

### 任意の加減算
減算は整数同士の加算と考えることができる.
加算の拡張から, 加減算は4通りある.

- $a+b$
- $a-b$
- $-a+b$
- $-a-b$
  （ここで$a \in \Z, b \in \Z $）

2の補数のような符号付表現であれば, $a>b$となるように順番を入れ替えできて, 
$a$の符号を基準に値が増減する演算であると考えられる.
オーバーフローやアンダーフローは符号の入れ替え(`a(a'left) /= x(x'left)`)で判別できる.

## 乗算
乗算ではビット数がそれぞれのビット数分だけ増える(`x'length-1 = a'length-1 + b'length-1`).
2のべき乗, つまり2進数で1つのビットのみが1の数はビットシフトで表現できる.
乗数が任意のときはほとんど使われないだろう.
例えば除算だが, 平均の個数を2のべき乗に固定するなどの設計が基本である.

それ以外の場合は乗算器を必要とする.
往々にして丁寧に（Wallace Treeなどで）設計したものより, コンパイラの推論の方が優れている
（乗算記号`*`で推論される）. 
FPGAにはハード乗算器が使えるものも多いので, ハード乗算器のサイズに合わせて設計すれば, 
ロジックの使用率を下げることができる（周波数も上げることができる）. 

### 負数を含む乗算
負数はあらかじめ表現を定義するため, 表現方法により乗算も異なる.
乗算では数は符号と絶対値に分解できるため, 浮動小数点のような符号を別に扱う表現が強力である.
演算は絶対値のみを扱い, 符号は後からつけてやればよい.

#### 2の補数における乗算[[1](signed_mpx)]
2の補数表現は符号と絶対値が分離できないため, 乗算においては特別な操作が必要である.
このとき乗算によってビット数が増えるため, 2の補数で得られる解もビット数が増える.
例えば$7 \times (-2)$:`0b0111`$\times$`0b1110`（4ビット表現）は`0b10010`（5ビット表現）ではなく`0b11110010`（8ビット表現）となる.

具体的な操作としては, 増えるビット数分だけ負数は上位ビットを1埋めしてやる必要がある.
```
     (0000)0111     7
   *)(1111)1110  *)-2
   ------------  ----
110 | 1111 0010   -14  
```
上位ビットの1埋めによって更に発生した上位桁は無視すると, 正しい結果が得られる.
[[1](signed_mpx)] [符号付き乗算－WentWayUp](https://wentwayup.tamaliver.jp/e165237.html)
     [https://wentwayup.tamaliver.jp/e165237.html](https://wentwayup.tamaliver.jp/e165237.html)
     
### 小数点を含む乗算
固定小数点であれば, 小数点の位置はあらかじめ決まっているため, 乗算を行っても小数点の位置は予測できる（固定される）.


## 除算
残念なことに除算はコンパイラによる推論が望めない.
そのため除算器は自分で設計する必要がある.

しかし除算器が必要な例は除数が任意の場合である.
除数が定数のものは固定小数点の乗算になる.
